I"!<h2 id="xpath---примеры-запросов">XPath - примеры запросов</h2>

<p>Для проверки запросов откройте <a href="/xpath-tests" target="_blank">тестовую страницу</a></p>

<p><em><strong>/</strong></em> - выбрать корневой узел длкумента</p>

<p><em><strong>/html</strong></em> - выбрать корневой элемент</p>

<p><em><strong>/html/body/div</strong></em> - выбрать элемент <em>div</em>, который является прямым наследником элемента body</p>

<p><em><strong>/html/body/div/*</strong></em> - выбрать все элементы, которые являются прямыми наследниками <em>div</em></p>

<p><em><strong>//li</strong></em> - выбрать все <em>div</em> элементы независимо от их позиции в документе</p>

<p><em><strong>//li[1]</strong></em> - выбрать первый дочерний элемент <em>li</em></p>

<p><em><strong>//li[last()]</strong></em> - выбрать последний дочерний элемент <em>li</em></p>

<p><em><strong>//li[position()&lt;3]</strong></em> - выбрать первый и второй дочерний элемент <em>li</em> в списке</p>

<p><em><strong>(//li)[2]</strong></em> - выбрать второй элемент в общей структуре</p>

<p><em><strong>//div[@name]</strong></em> - выбрать все <em>div</em> элементы, у которых есть атрибут <em>name</em></p>

<p><em><strong>//div[@name=’content’]</strong></em> - выбрать все <em>div</em> элементы у которых значение атрибута <em>name</em> равно <em>content</em></p>

<p><em><strong>//div[@name=’content’ or @class]</strong></em> - выбрать все <em>div</em> элементы у которых значение <em>name</em> равно <em>content</em> или если у них есть атрибут <em>class</em></p>

<p><em><strong>and</strong></em> - должны выполняться оба условия</p>

<p><em><strong>or</strong></em> - должно выполняться хоть одно их условий</p>

<p><em><strong>not()</strong></em> - инверсия значения</p>

<p><em><strong>//div[contains(@class, ‘btn’)]</strong></em> - выбрать все <em>div</em> элементы у которых атрибут <em>class</em> содержит подстроку <em>btn</em></p>

<p><em><strong>//div[text()=’hello world’]</strong></em> - выбрать все элементы <em>div</em> внутри которых текст является hello world</p>

<p><em><strong>//div[contains(., ‘world’)]</strong></em> - выбрать все элементы <em>div</em> у которых любой из вложенных элементов содержит слово <em>world</em></p>

<p><em><strong>//div[./span]</strong></em> - выбрать все элементы <em>div</em> у которых есть прямой наследник <em>span</em></p>

<p><em><strong>//div | //span</strong></em> - выбрать все элементы <em>div</em> или <em>span</em></p>

<h3 id="оси">Оси</h3>
<p>Оси — это база языка XPath. Для некоторых осей существуют сокращённые обозначения.</p>

<p><em><strong>child::</strong></em> — содержит множество элементов-потомков (элементов, расположенных на один уровень ниже). Это название сокращается полностью, то есть его можно вовсе опускать.</p>

<p><em><strong>descendant::</strong></em> — содержит полное множество элементов-потомков (то есть, как ближайших элементов-потомков, так и всех их элементов-потомков).</p>

<p><em><strong>descendant-or-self::</strong></em> — содержит полное множество элементов-потомков и текущий элемент. Выражение /descendant-or-self::node()/ можно сокращать до //. С помощью этой оси, например, можно вторым шагом организовать отбор элементов с любого узла, а не только с корневого: достаточно первым шагом взять всех потомков корневого. Например, путь //span отберёт все узлы span документа, независимо от их положения в иерархии, взглянув как на имя корневого, так и на имена всех его дочерних элементов, на всю глубину их вложенности.</p>

<p><em><strong>ancestor::</strong></em> — содержит множество элементов-предков.</p>

<p><em><strong>ancestor-or-self::</strong></em> — содержит множество элементов-предков и текущий элемент.</p>

<p><em><strong>parent::</strong></em> — содержит элемент-предок на один уровень назад. Это обращение можно заменить на ..</p>

<p><em><strong>self::</strong></em> — содержит текущий элемент. Это обращение можно заменить на .</p>

<p><em><strong>following::</strong></em> — содержит множество элементов, расположенных ниже текущего элемента по дереву (на всех уровнях и слоях), исключая собственных потомков.</p>

<p><em><strong>following-sibling::</strong></em> — содержит множество братских элементов того же уровня, следующих за текущим слоем.</p>

<p><em><strong>preceding::</strong></em> — содержит множество элементов, расположенных выше текущего элемента по дереву (на всех уровнях и слоях), исключая множество собственных предков.</p>

<p><em><strong>preceding-sibling::</strong></em> — содержит множество братских элементов того же уровня, предшествующих текущему слою.</p>

<p><em><strong>attribute::</strong></em> — содержит множество атрибутов текущего элемента. Это обращение можно заменить на символ @</p>

<p><em><strong>namespace::</strong></em> — содержит множество элементов, относящихся к тому или иному пространству имён (то есть присутствует атрибут xmlns).</p>
:ET